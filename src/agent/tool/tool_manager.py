"""
Dynamic Tool Manager Module

This module provides functionality for dynamically loading, registering,
and managing function tools generated by the coding agent.
"""

import os
import sys
import json
import importlib
import importlib.util
from typing import Dict, List, Any, Optional, Callable
from pathlib import Path
import logging
from datetime import datetime


class ToolManager:
    """
    Dynamic tool manager for loading and managing generated function tools
    """
    
    def __init__(self, tools_dir: str = "src/agent/tool/generated"):
        """
        Initialize the tool manager
        
        Args:
            tools_dir: Directory containing generated tools
        """
        self.tools_dir = Path(tools_dir)
        self.tools_dir.mkdir(parents=True, exist_ok=True)
        
        self.logger = self._setup_logging()
        self.loaded_tools: Dict[str, Callable] = {}
        self.tool_modules: Dict[str, Any] = {}
        
        # Load metadata
        self.metadata_file = self.tools_dir / "tool_metadata.json"
        self.metadata = self._load_metadata()
        
    def _setup_logging(self) -> logging.Logger:
        """Setup logging configuration"""
        return logging.getLogger('tool_manager')
    
    def _load_metadata(self) -> Dict[str, Any]:
        """Load tool metadata from file"""
        if self.metadata_file.exists():
            try:
                with open(self.metadata_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                self.logger.warning(f"Failed to load metadata: {e}")
        
        return {
            "tools": {},
            "versions": {},
            "dependencies": {},
            "usage_history": {}
        }
    
    def _save_metadata(self):
        """Save tool metadata to file"""
        try:
            with open(self.metadata_file, 'w') as f:
                json.dump(self.metadata, f, indent=2, default=str)
        except Exception as e:
            self.logger.error(f"Failed to save metadata: {e}")
    
    def discover_tools(self) -> List[str]:
        """
        Discover all available tool files in the tools directory
        
        Returns:
            List of tool file names (without .py extension)
        """
        tool_files = []
        for py_file in self.tools_dir.glob("*.py"):
            if py_file.name != "__init__.py" and not py_file.name.startswith("_"):
                tool_files.append(py_file.stem)
        
        return tool_files
    
    def load_tool(self, tool_name: str) -> Optional[Callable]:
        """
        Dynamically load a tool from file
        
        Args:
            tool_name: Name of the tool to load
            
        Returns:
            Loaded function tool or None if failed
        """
        try:
            tool_file = self.tools_dir / f"{tool_name}.py"
            if not tool_file.exists():
                self.logger.error(f"Tool file not found: {tool_file}")
                return None
            
            # Load module dynamically
            spec = importlib.util.spec_from_file_location(tool_name, tool_file)
            if spec is None or spec.loader is None:
                self.logger.error(f"Failed to create spec for {tool_name}")
                return None
            
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # Find the main function (should have same name as file)
            if hasattr(module, tool_name):
                tool_func = getattr(module, tool_name)
                self.loaded_tools[tool_name] = tool_func
                self.tool_modules[tool_name] = module
                
                # Update usage history
                if tool_name not in self.metadata["usage_history"]:
                    self.metadata["usage_history"][tool_name] = []
                
                self.metadata["usage_history"][tool_name].append({
                    "action": "loaded",
                    "timestamp": datetime.now().isoformat()
                })
                
                self.logger.info(f"Successfully loaded tool: {tool_name}")
                return tool_func
            else:
                self.logger.error(f"Function {tool_name} not found in module")
                return None
                
        except Exception as e:
            self.logger.error(f"Failed to load tool {tool_name}: {e}")
            return None
    
    def load_all_tools(self) -> Dict[str, Callable]:
        """
        Load all available tools from the tools directory
        
        Returns:
            Dictionary mapping tool names to function objects
        """
        discovered_tools = self.discover_tools()
        loaded_count = 0
        
        for tool_name in discovered_tools:
            if self.load_tool(tool_name):
                loaded_count += 1
        
        self.logger.info(f"Loaded {loaded_count} of {len(discovered_tools)} tools")
        return self.loaded_tools
    
    def reload_tool(self, tool_name: str) -> Optional[Callable]:
        """
        Reload a tool (useful for development and updates)
        
        Args:
            tool_name: Name of the tool to reload
            
        Returns:
            Reloaded function tool or None if failed
        """
        try:
            # Remove from loaded tools if exists
            if tool_name in self.loaded_tools:
                del self.loaded_tools[tool_name]
            
            if tool_name in self.tool_modules:
                del self.tool_modules[tool_name]
            
            # Reload
            return self.load_tool(tool_name)
            
        except Exception as e:
            self.logger.error(f"Failed to reload tool {tool_name}: {e}")
            return None
    
    def get_tool(self, tool_name: str) -> Optional[Callable]:
        """
        Get a loaded tool by name
        
        Args:
            tool_name: Name of the tool
            
        Returns:
            Function tool or None if not found
        """
        return self.loaded_tools.get(tool_name)
    
    def get_all_tools(self) -> Dict[str, Callable]:
        """
        Get all loaded tools
        
        Returns:
            Dictionary of all loaded tools
        """
        return self.loaded_tools.copy()
    
    def get_tool_info(self, tool_name: str) -> Optional[Dict[str, Any]]:
        """
        Get information about a tool
        
        Args:
            tool_name: Name of the tool
            
        Returns:
            Tool information dictionary or None if not found
        """
        if tool_name in self.metadata["tools"]:
            return self.metadata["tools"][tool_name]
        
        # Try to get info from loaded module
        if tool_name in self.tool_modules:
            module = self.tool_modules[tool_name]
            if hasattr(module, 'TOOL_METADATA'):
                return module.TOOL_METADATA
        
        return None
    
    def validate_tool(self, tool_name: str) -> Dict[str, Any]:
        """
        Validate a tool's functionality and requirements
        
        Args:
            tool_name: Name of the tool to validate
            
        Returns:
            Validation results dictionary
        """
        validation_result = {
            "valid": False,
            "errors": [],
            "warnings": [],
            "tool_name": tool_name
        }
        
        try:
            # Check if tool file exists
            tool_file = self.tools_dir / f"{tool_name}.py"
            if not tool_file.exists():
                validation_result["errors"].append(f"Tool file not found: {tool_file}")
                return validation_result
            
            # Try to load the tool
            tool_func = self.get_tool(tool_name)
            if tool_func is None:
                tool_func = self.load_tool(tool_name)
            
            if tool_func is None:
                validation_result["errors"].append("Failed to load tool function")
                return validation_result
            
            # Check function signature
            if not callable(tool_func):
                validation_result["errors"].append("Tool is not callable")
                return validation_result
            
            # Check if it has proper docstring
            if not tool_func.__doc__:
                validation_result["warnings"].append("Tool lacks documentation")
            
            # Validate metadata if available
            tool_info = self.get_tool_info(tool_name)
            if tool_info:
                required_fields = ["name", "description", "parameters"]
                for field in required_fields:
                    if field not in tool_info:
                        validation_result["warnings"].append(f"Missing metadata field: {field}")
            
            validation_result["valid"] = True
            self.logger.info(f"Tool {tool_name} validation passed")
            
        except Exception as e:
            validation_result["errors"].append(f"Validation error: {str(e)}")
            self.logger.error(f"Tool {tool_name} validation failed: {e}")
        
        return validation_result
    
    def unload_tool(self, tool_name: str) -> bool:
        """
        Unload a tool from memory
        
        Args:
            tool_name: Name of the tool to unload
            
        Returns:
            True if successfully unloaded, False otherwise
        """
        try:
            if tool_name in self.loaded_tools:
                del self.loaded_tools[tool_name]
            
            if tool_name in self.tool_modules:
                del self.tool_modules[tool_name]
            
            # Update usage history
            if tool_name in self.metadata["usage_history"]:
                self.metadata["usage_history"][tool_name].append({
                    "action": "unloaded",
                    "timestamp": datetime.now().isoformat()
                })
            
            self.logger.info(f"Successfully unloaded tool: {tool_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to unload tool {tool_name}: {e}")
            return False
    
    def register_tool(self, 
                     tool_name: str,
                     tool_func: Callable,
                     metadata: Optional[Dict[str, Any]] = None) -> bool:
        """
        Register a tool function with the manager
        
        Args:
            tool_name: Name of the tool
            tool_func: Function object
            metadata: Optional metadata dictionary
            
        Returns:
            True if successfully registered, False otherwise
        """
        try:
            self.loaded_tools[tool_name] = tool_func
            
            if metadata:
                self.metadata["tools"][tool_name] = metadata
                self._save_metadata()
            
            # Update usage history
            if tool_name not in self.metadata["usage_history"]:
                self.metadata["usage_history"][tool_name] = []
            
            self.metadata["usage_history"][tool_name].append({
                "action": "registered",
                "timestamp": datetime.now().isoformat()
            })
            
            self.logger.info(f"Successfully registered tool: {tool_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to register tool {tool_name}: {e}")
            return False
    
    def get_usage_statistics(self) -> Dict[str, Any]:
        """
        Get usage statistics for all tools
        
        Returns:
            Dictionary containing usage statistics
        """
        stats = {
            "total_tools": len(self.loaded_tools),
            "available_tools": len(self.discover_tools()),
            "usage_history": self.metadata.get("usage_history", {}),
            "tools_by_status": {
                "loaded": len(self.loaded_tools),
                "available": len(self.discover_tools()),
                "unloaded": len(self.discover_tools()) - len(self.loaded_tools)
            }
        }
        
        return stats
    
    def cleanup_unused_tools(self, max_age_days: int = 30) -> List[str]:
        """
        Clean up tools that haven't been used for a specified period
        
        Args:
            max_age_days: Maximum age in days before considering a tool unused
            
        Returns:
            List of cleaned up tool names
        """
        from datetime import datetime, timedelta
        
        cleaned_tools = []
        cutoff_date = datetime.now() - timedelta(days=max_age_days)
        
        for tool_name in list(self.loaded_tools.keys()):
            last_used = None
            
            if tool_name in self.metadata["usage_history"]:
                history = self.metadata["usage_history"][tool_name]
                if history:
                    last_used_str = history[-1].get("timestamp")
                    if last_used_str:
                        try:
                            last_used = datetime.fromisoformat(last_used_str)
                        except:
                            pass
            
            if last_used is None or last_used < cutoff_date:
                if self.unload_tool(tool_name):
                    cleaned_tools.append(tool_name)
        
        self.logger.info(f"Cleaned up {len(cleaned_tools)} unused tools")
        return cleaned_tools
    
    def export_tools_manifest(self) -> Dict[str, Any]:
        """
        Export a manifest of all available tools
        
        Returns:
            Dictionary containing tools manifest
        """
        manifest = {
            "generated_at": datetime.now().isoformat(),
            "tools_directory": str(self.tools_dir),
            "tools": {},
            "statistics": self.get_usage_statistics()
        }
        
        for tool_name in self.discover_tools():
            tool_info = self.get_tool_info(tool_name)
            validation = self.validate_tool(tool_name)
            
            manifest["tools"][tool_name] = {
                "loaded": tool_name in self.loaded_tools,
                "valid": validation["valid"],
                "info": tool_info,
                "validation": validation
            }
        
        return manifest


# Global tool manager instance
_global_tool_manager = None


def get_tool_manager() -> ToolManager:
    """
    Get the global tool manager instance
    
    Returns:
        Global ToolManager instance
    """
    global _global_tool_manager
    if _global_tool_manager is None:
        _global_tool_manager = ToolManager()
    return _global_tool_manager


def load_dynamic_tools() -> Dict[str, Callable]:
    """
    Convenience function to load all dynamic tools
    
    Returns:
        Dictionary of loaded tools
    """
    manager = get_tool_manager()
    return manager.load_all_tools()


def get_dynamic_tool(tool_name: str) -> Optional[Callable]:
    """
    Convenience function to get a specific dynamic tool
    
    Args:
        tool_name: Name of the tool
        
    Returns:
        Tool function or None if not found
    """
    manager = get_tool_manager()
    return manager.get_tool(tool_name) 